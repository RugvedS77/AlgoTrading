# agents/risk_supervisor_agent.py

import json
from typing import Dict, Any, Optional
from schemas.risk_schema import RiskSupervisorResponse
from schemas.capital_schema import PortfolioState # Removed unused CapitalAllocatorResponse

try:
    from langchain_google_genai import ChatGoogleGenerativeAI
except ImportError:
    ChatGoogleGenerativeAI = None

class RiskSupervisorAgent:
    def __init__(
        self,
        llm_model: str = "gemini-1.5-flash",
        google_api_key: Optional[str] = None,
        temperature: float = 0.1,
    ):
        if ChatGoogleGenerativeAI is None:
            raise RuntimeError("langchain_google_genai not installed.")
            
        self._llm = ChatGoogleGenerativeAI(
            model=llm_model,
            temperature=temperature,
            google_api_key=google_api_key,
        )

        # MODIFICATION: The curly braces {} for the JSON schema example below are now
        # DOUBLED to {{ and }} so Python's .format() method ignores them.
        # The actual data placeholders at the end are correctly left as SINGLE braces.
        self._prompt_template = """You are a Chief Risk Officer (CRO) for a quantitative Algorithmic trading desk. Your task is to provide a final, supervisory review of a proposed trade setup generated by two subordinate agents: a Signal Agent and a Capital Allocator.

You must synthesize all provided data and provide a clear, final verdict. Look for contradictions, excessive risk, or misalignments between the signal's confidence and the proposed capital allocation.

**Your final output MUST be a strict JSON object with the following schema:**
{{
  "final_verdict": "'PROCEED' | 'PROCEED WITH CAUTION' | 'REJECT'",
  "summary_rationale": "A concise, one-sentence summary of your decision.",
  "key_positive_factors": ["A list of strings supporting the trade."],
  "key_risks_and_concerns": ["A list of strings highlighting the risks."],
  "suggested_action": "'BUY' | 'SELL' | 'HOLD'"
}}

---
**RAW AGENT DATA TO ANALYZE:**

**Signal Agent Output:**
{signal_agent_output}

**Capital Allocator Output:**
{capital_allocator_output}

**Current Portfolio State:**
{portfolio_state}
"""

    def review_trade_setup(
        self,
        signal_output: Dict[str, Any],
        allocation_output: Dict[str, Any],
        portfolio_state: PortfolioState,
    ) -> RiskSupervisorResponse:
        
        prompt = self._prompt_template.format(
            signal_agent_output=json.dumps(signal_output, indent=2),
            capital_allocator_output=json.dumps(allocation_output, indent=2),
            portfolio_state=portfolio_state.model_dump_json(indent=2)
        )
        
        raw_response = self._llm.invoke(prompt).content.strip()
        
        try:
            if raw_response.startswith("```json"):
                raw_response = raw_response[7:-3].strip()
            
            parsed_data = json.loads(raw_response)
            return RiskSupervisorResponse(**parsed_data)
        except (json.JSONDecodeError, TypeError) as e:
            print(f"Error parsing LLM response for risk review: {e}")
            return RiskSupervisorResponse(
                final_verdict="REJECT",
                summary_rationale="Failed to parse supervisory model response. Rejecting as a safety measure.",
                key_positive_factors=[],
                key_risks_and_concerns=["LLM output was not valid JSON."],
                suggested_action="HOLD"
            )

# from __future__ import annotations
# from dataclasses import dataclass
# from typing import List, Dict
# import math

# from schemas.risk_schema import RiskFilterRequest, RiskFilterResponse

# # ---- config thresholds ----
# CONFIDENCE_MIN = 0.60
# VOLATILITY_MAX = 0.05        # 5% daily std dev
# STOP_LOSS_PCT = 0.03         # 3% per trade
# RR_MIN = 1.5
# NEWS_NEG_CUTOFF = -0.50
# ALLOW_BUY_ON_NEG_NEWS = False


# # @dataclass
# # class RiskFilterInput:
# #     ticker: str
# #     signal: str               # BUY | SELL | HOLD
# #     confidence: float
# #     sources: Dict[str, float]
# #     current_price: float
# #     predicted_price: float


# # @dataclass
# # class RiskFilterDecision:
# #     decision: str             # APPROVED | REJECTED | UNDER REVIEW
# #     action: str
# #     reasons: List[str]
# #     metrics: Dict[str, float]
# #     message: str


# def _reward_risk(curr: float, pred: float) -> Dict[str, float]:
#     risk = abs(curr * STOP_LOSS_PCT)
#     reward = abs(pred - curr)
#     rr = (reward / risk) if risk > 0 else 0.0
#     return {"risk": risk, "reward": reward, "rr": rr}


# def run_risk_filter(payload: RiskFilterRequest) -> RiskFilterResponse:
#     reasons, metrics = [], {}
#     action = payload.signal
#     decision = "APPROVED"   # default

#     # 1) confidence
#     metrics["confidence"] = payload.confidence
#     if payload.confidence < CONFIDENCE_MIN:
#         reasons.append(f"confidence {payload.confidence:.2f} < {CONFIDENCE_MIN}")
#         decision, action = "REJECTED", "HOLD"
#         if payload.confidence >= CONFIDENCE_MIN - 0.05:  # borderline case
#             decision = "UNDER REVIEW"

#     # 2) news impact
#     news_score = float(payload.sources.get("news_score", 0.0))
#     metrics["news_score"] = news_score
#     if news_score <= NEWS_NEG_CUTOFF and payload.signal == "BUY":
#         if not ALLOW_BUY_ON_NEG_NEWS:
#             reasons.append(f"negative news_score {news_score:.2f} ≤ {NEWS_NEG_CUTOFF}")
#             decision, action = "REJECTED", "HOLD"

#     # 3) reward:risk
#     rr_metrics = _reward_risk(payload.current_price, payload.predicted_price)
#     metrics.update(rr_metrics)
#     if rr_metrics["rr"] < RR_MIN:
#         reasons.append(f"R/R {rr_metrics['rr']:.2f} < {RR_MIN}")
#         decision, action = "REJECTED", "HOLD"

#     # final reasons
#     if not reasons:
#         reasons.append("all checks passed")

#     # --- human explanation ---
#     if decision == "APPROVED":
#         message = "✅ This trade looks good. The prediction is strong, news sentiment is supportive, and the risk/reward ratio is favorable."
#     elif decision == "UNDER REVIEW":
#         message = "⚠️ This trade is borderline. Some signals are weak, proceed with caution."
#     else:
#         parts = []
#         if payload.confidence < CONFIDENCE_MIN:
#             parts.append("the prediction is weak")
#         if news_score <= NEWS_NEG_CUTOFF:
#             parts.append("news is negative")
#         if rr_metrics["rr"] < RR_MIN:
#             parts.append("the potential loss is bigger than the potential gain")

#         message = "❌ Don’t take this trade right now. " + ", ".join(parts) + "."

#     return RiskFilterResponse(decision=decision, action=action, reasons=reasons, metrics=metrics, message=message)